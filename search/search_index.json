{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AquaPack Robotics Documentation","text":"<p>Documentation for AquaPack Robotics systems and standards. Documentation for individual robots can be found in the \"Robots\" heading of the top-bar.</p>"},{"location":"electrical/standards/","title":"Standards","text":"<p>Note that this page is currently an outline and most of the content is not yet written.</p>"},{"location":"electrical/standards/#connectors","title":"Connectors","text":"<p>Waterproof (external) Connections</p> <ul> <li>Wire to Endcap (detachable): Fischers</li> <li>Wire to Endcap (not detachable): BlueRobotics penetrators (wetlink penetrators should be preferred over potted penetrators)</li> <li>Wire to Wire: Either use an epoxy filled block or waterproof heatshrink </li> </ul> <p>Signal &amp; Low Current:</p> <ul> <li>Wire to Wire: JST SM</li> <li>Wire to Board: Molex KK 254</li> <li>Fallback (either): DuPont (use only when JST-SM or Molex KK 254 are not viable, recommended only for prototyping)</li> </ul> <p>Higher Current</p> <ul> <li>Wire to Wire or Wire to Board: Powerpole (PP15-45 series)</li> <li>Wire to Wire: XT90 (use these only for connections directly to battery or where current larger than 45A is required)</li> <li>Wire to Screw Terminal: Heat shrink ring connectors</li> </ul>"},{"location":"electrical/standards/#dupont-connectors","title":"DuPont Connectors","text":"<ul> <li>Wire to wire</li> <li>Wire to board when paired with standard 2.54mm pin headers</li> <li>Intended for signals not power (2A max per pin)</li> <li>Cheap and easy to get (kits easily found on Amazon)</li> <li>Moderately difficult to crimp</li> <li>Not keyed</li> <li>Male pins are easy to bend / break both when connected and when not connected</li> <li>Pair well with standard 2.54mm pin headers</li> <li>Work with breadboards</li> <li>Housings in two-row configurations are sold</li> </ul>"},{"location":"electrical/standards/#molex-kk-254-connectors","title":"Molex KK 254 Connectors","text":"<ul> <li>Wire to board</li> <li>Intended for signals (4A max per pin, less depending on crimp pin selection)</li> <li>More expensive than DuPont connectors (but better)</li> <li>No kits sold, must buy individually from digikey / mouser</li> <li>Moderately difficult to crimp</li> <li>Keyed</li> <li>Male pins always on board. Only female crimps for wire.</li> <li>2.54mm pin pitch, so compatible with DuPont connectors and standard pin headers if necessary</li> <li>Housings only in one-row configurations</li> </ul>"},{"location":"electrical/standards/#jst-sm-connectors","title":"JST SM Connectors","text":"<ul> <li>Wire to Wire</li> <li>Intended for signals (2A max per pin)</li> <li>Can find in kits on Amazon (harder to find than DuPont, but possible)</li> <li>Moderately difficult to crimp</li> <li>Keyed</li> <li>Latching</li> <li>Protected male pins (both when connected and not connected)</li> <li>Housings only in one-row configurations</li> </ul>"},{"location":"electrical/standards/#anderson-power-powerpole-connectors-pp15-45-series","title":"Anderson Power Powerpole Connectors (PP15-45 series)","text":"<ul> <li>Wire to Wire or Wire to Board</li> <li>Intended for power (15, 30, 45 A)</li> <li>Expensive</li> <li>Easy to crimp</li> <li>Keyed</li> <li>Same housing / pin used on both sides of connection</li> <li>Custom configurations possible (custom size and key of connector block)</li> <li>Recommended for wire from 20 to 10 AWG</li> </ul>"},{"location":"electrical/standards/#xt90-connectors","title":"XT90 Connectors","text":"<p>Note that XT60 connectors are rarely used, but are generally the same idea (just lower current rating). XT60 connectors are only used on the battery chargers and should not be used on the robot itself.</p> <p></p> <ul> <li>Wire to Wire</li> <li>Wire to Board may be possible, but not recommended.</li> <li>Soldered not crimped</li> <li>Somewhat difficult to solder (generally requires heatsink and large iron tip)</li> <li>Robust connectors</li> <li>Work well with larger gauge wire only (14-10 AWG)</li> </ul>"},{"location":"electrical/standards/#heat-shrink-ring-connectors","title":"Heat Shrink Ring Connectors","text":"<p>Note: There are variants of these sold that are \"U\" shaped (not a closed ring). These are not to be used on the robot as they easily come loose.</p> <p></p> <ul> <li>Wire to screw terminal</li> <li>Can be used wire to wire with a loose screw &amp; nut, but not recommended.</li> <li>Easy to crimp</li> <li>Generally can handle the same current as any wire that can fit inside them</li> </ul>"},{"location":"electrical/standards/#pcb-headers","title":"PCB Headers","text":"<ul> <li>Standard 2.54mm headers (right angle and vertical)</li> <li>KK 254 headers (right angle and vertical)</li> <li>Powerpole headers (right angle and vertical)</li> </ul>"},{"location":"electrical/standards/#electronic-assembly","title":"Electronic Assembly","text":"<ul> <li>PCBs</li> <li>Protoboard</li> <li>Breadboard (avoid on robot, if necessary hot glue EVERYTHING)</li> </ul>"},{"location":"electrical/standards/#microcontrollers","title":"Microcontrollers","text":"<p>Custom boards integrating microcontrollers should use TI's MSP430 series of MCUs. This family of microcontrollers integrates the required features and are generally powerful enough for our use cases. Additionally, NCSU's ECE department has an embedded systems course built around these microcontrollers, thus it helps align club operation with coursework.</p> <p>If there is no compelling reason not to, TI's MSP430FR2355 is recommended. This chip integrates almost any peripheral that would be required, has many serial communication interfaces, and has more GPIO pins than would typically be used. The LQFT-48 package version of this chip is easy enough to hand solder as well.</p> <p>If there is a compelling reason to select a different MSP430, this is permissable, however it should be attempted to use a chip that can be more easily hand soldered. Avoid QFN and BGA packages (or anything else with pads contained under the chip).</p> <p>In cases where an MSP430 does not provide sufficient power for what is being designed, it is recommended to use an Arm architecture microcontroller. There are many vendors of these on the market (not a complete list):</p> <ul> <li>TI's MSP432 series</li> <li>TI's MSP-M0 series</li> <li>Microchip's SAM series</li> <li>ST Microelectronics STM32 chips</li> <li>Raspberry Pi RP2040</li> <li>Many NXP Semiconductors chips</li> </ul> <p>When choosing a chip, make sure to also research the cost of a debug probe. For example, the STM32 series are compatible with low cost ST-Link debug probes.</p>"},{"location":"electrical/standards/#fpgas","title":"FPGAs","text":"<p>FPGAs supported by Vivado are preferred.</p>"},{"location":"electrical/standards/#ic-packages","title":"IC Packages","text":"<p>Integrated circuits used on our boards should be hand solderable. Avoid QFN and BGA packages (or anything else with pads contained under the chip). This can be violated if absolutely necessary, however make sure there is an assembly plan.</p>"},{"location":"electrical/connectors/crimping/","title":"Crimped Connectors","text":"<p>Note that this page is currently an outline and most of the content is not yet written.</p>"},{"location":"electrical/connectors/crimping/#dupont-connectors","title":"DuPont Connectors","text":""},{"location":"electrical/connectors/crimping/#tools","title":"Tools","text":"<p>Recommended: IWISS / iCrimp SN-025 Crimper:</p> <p>This crimper will crimp both the insulation and the conductor portions at once. Unlike the more common SN-28B crimpers, these will crimp the insulation properly (rounded shape, not an \"m\" shape).</p> <p>Note that for smaller wires (28 AWG and smaller) this may not crimp the conductor portion properly. Thus, you may need to use needle nose pliers to press the conductor tabs down further.</p> <p></p> <p>Alternate: SN-28B Crimper:</p> <p>Similar to the SN-025 crimpers (and much more common), however they do not crimp the insulation portion properly. Thus, you will likely need to use needle nose pliers to \"round out\" the insulation crimp for the pin to fit in the housing.</p> <p></p> <p>Alternate: PA-20 Crimper</p> <p>This tool crimps only one portion (conductor or insulation) at a time, however is sometimes easier to use because of that. This tool is an \"m\" shaped crimp, thus it will not quite crimp the insulation part correctly, however if you do not press down fully on that part it is usually good enough.</p> <p></p>"},{"location":"electrical/connectors/crimping/#crimping-process","title":"Crimping Process","text":"<p>TODO</p>"},{"location":"electrical/connectors/crimping/#molex-kk-254-connectors","title":"Molex KK 254 Connectors","text":""},{"location":"electrical/connectors/crimping/#tools_1","title":"Tools","text":""},{"location":"electrical/connectors/crimping/#crimping-process_1","title":"Crimping Process","text":"<p>TODO</p>"},{"location":"electrical/connectors/crimping/#jst-sm-connectors","title":"JST SM Connectors","text":"<p>These connectors are keyed wire to wire connectors. Additionally, they latch into place when connected and are resistant to bending of male pins (both when connected and when not connected).</p> <p></p>"},{"location":"electrical/connectors/crimping/#tools_2","title":"Tools","text":"<p>Note: Information in this section is speculative and not yet verified.</p> <p>A crimp tool making an \"m\" shaped crimp is required. The PA-20 crimper is used for this. It can be used for both the insulation and the conductor crimp portions.</p> <p></p>"},{"location":"electrical/connectors/crimping/#crimping-process_2","title":"Crimping Process","text":"<p>TODO</p>"},{"location":"electrical/connectors/crimping/#powerpole-connectors-pp15-45","title":"Powerpole Connectors (PP15-45)","text":""},{"location":"electrical/connectors/crimping/#tools_3","title":"Tools","text":"<p>The TRIcrimp Powerpole crimp tool should be used. These are reasonably priced and are easily the best Powerpole crimp tool.</p> <p></p>"},{"location":"electrical/connectors/crimping/#crimping-process_3","title":"Crimping Process","text":"<p>TODO</p>"},{"location":"electrical/connectors/crimping/#heatshrink-ring-connectors","title":"Heatshrink Ring Connectors","text":""},{"location":"electrical/connectors/crimping/#tools_4","title":"Tools","text":"<p>TODO</p>"},{"location":"electrical/connectors/crimping/#crimping-process_4","title":"Crimping Process","text":"<p>TODO</p>"},{"location":"electrical/connectors/fischers/","title":"Fischers","text":"<p>Note that this page is currently an outline and most of the content is not yet written.</p>"},{"location":"electrical/connectors/soldering/","title":"Soldered Connectors","text":"<p>Note that this page is currently an outline and most of the content is not yet written.</p>"},{"location":"electrical/connectors/soldering/#xt90-connectors","title":"XT90 Connectors","text":"<p>TODO</p>"},{"location":"electrical/connectors/waterproof_splice/","title":"Waterproof Splicing","text":"<p>Note that this page is currently an outline and most of the content is not yet written.</p> <ul> <li>Adhesive heatshrink method</li> <li>Epoxy block method</li> </ul>"},{"location":"electrical/embedded/msp430/","title":"Msp430","text":"<p>Note that this page is currently an outline and most of the content is not yet written.</p> <p>TODO: What software we use and why</p> <p>TODO: Links to user guides for the software</p> <p>TODO: Debug probes, using ez-FET from launchpad</p> <p>TODO: Drivelib</p> <p>TODO: Custom library</p>"},{"location":"electrical/embedded/styleguide/","title":"Style Guide","text":"<p>AquaPack Robotics Embedded Programming Style Guide</p> <p>Note, this page is currently in the process of being written</p>"},{"location":"electrical/embedded/styleguide/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Table of Contents</li> <li>Overview</li> <li>Rules</li> <li>General Rules<ul> <li>Line Width</li> <li>Braces</li> <li>Parentheses</li> <li>Common Abbreviations</li> <li>Casts</li> <li>Keywords</li> </ul> </li> <li>Comment Rules<ul> <li>Comment Locations</li> </ul> </li> <li>White Space Rules<ul> <li>Pointer (* and \\&amp;) Operators</li> <li>Alignment Rules</li> <li>Tab Rules</li> </ul> </li> <li>Module Rules<ul> <li>Naming Conventions</li> <li>Header Files</li> <li>Source Files</li> </ul> </li> <li>Data Type Rules<ul> <li>Type Definitions</li> <li>Use of Types</li> </ul> </li> <li>Procedure Rules</li> <li>Variable Rules</li> <li>Statement Rules</li> </ul>"},{"location":"electrical/embedded/styleguide/#overview","title":"Overview","text":"<p>This guide follows the general outline and some of the recommendations of Barr Group's Embedded C Coding Standard, set forth by Michael Barr.</p> <p>Many of these rules are common sense and you probably are already following them in your own coding style. However, for consistency across the team it is practical to write them explicitly.</p> <p>??? info Last updated: 2023-09-06 12:16 PM</p>"},{"location":"electrical/embedded/styleguide/#rules","title":"Rules","text":""},{"location":"electrical/embedded/styleguide/#general-rules","title":"General Rules","text":""},{"location":"electrical/embedded/styleguide/#line-width","title":"Line Width","text":"<ol> <li>No line width is enforced as we do not do paper code reviews. Please use your best discretion for when a line is considered too long (if you're not sure, try to keep the longest line to around 80 characters).</li> <li>The preprocessor directive (<code>#define</code>) should not be used to alter or rename any keyword or other part of the C programming language.</li> <li>The minimum target standard for both C and C++ is C/C++ 11. However, if newer versions such as 14 or 17 are available for the toolchain in use, they are preferred.</li> </ol>"},{"location":"electrical/embedded/styleguide/#braces","title":"Braces","text":"<ol> <li> <p>Left braces should appear on the same line as the statement they are connected with. Right braces should always be on a new line after their associated block of code.</p> Example<pre><code>if (condition) {\n    code block;\n} else {\n    code block line 2;\n    code block line 1;\n    code block line 3;\n}\n</code></pre> </li> </ol>"},{"location":"electrical/embedded/styleguide/#parentheses","title":"Parentheses","text":"<ol> <li>To maintain clarity of long expressions, parentheses should be used to ensure proper execution order and provide better information to maintainers.</li> <li>For further clarity, each side of a logical operator should be surrounded with parentheses, unless it is a single level operation.</li> </ol> Example<pre><code>(current_depth == target_depth) &amp;&amp; (current_depth &lt; pool_depth)\n\nsoft_arm &amp;&amp; hard_arm\n</code></pre>"},{"location":"electrical/embedded/styleguide/#common-abbreviations","title":"Common Abbreviations","text":"<ol> <li>Unless it is an abbreviation in common use and understood widely among programmers, refrain from using abbreviations as they can obfuscate the meaning of code.</li> <li>Common variable names, such as <code>i</code> for a loop counter can be used under the condition that it is of limited scope and purpose, and that the context it is in is exceedingly clear.</li> </ol>"},{"location":"electrical/embedded/styleguide/#casts","title":"Casts","text":"<ol> <li>Should a cast be required, the relevant lines should be commented to explain assumptions made.</li> </ol>"},{"location":"electrical/embedded/styleguide/#keywords","title":"Keywords","text":"<ol> <li>The use of <code>goto</code> should be exceedingly limited to only cases where it is justifiably required, and no other solution can be found (including rewriting other code to make the <code>goto</code> unecessary).</li> <li>Uses of the <code>continue</code> keyword should be limited, but are allowed where it simplifies the code structure and makes it more legible.</li> <li>Generally if something can be defined as <code>static</code>, it should be.</li> <li><code>const</code> should be applied in all locations where appropriate. In some cases, it may be more applicable than a preprocessor directive, while the preprocessor directive may be more applicable in others.</li> <li><code>volatile</code> should be used in all cases where a variable can be modified by anything outside of the normal control flow of the code (i.e. an ISR, variables shared between RTOS threads, etc).</li> </ol>"},{"location":"electrical/embedded/styleguide/#comment-rules","title":"Comment Rules","text":"<ol> <li>Both single (//) and multi (/*) comment styles are considered acceptable, and should be used as applicable. When multi-line comments are used, all lines should begin with an asterisk (*)</li> <li>Multi-line comments should maintain a level of indentation with the leading asterisks vertical to each other, as shown below.</li> <li>One leading space should be put between the comment text and the comment symbol.</li> <li>If placed at the end of a line of code, all comments should be vertically aligned (within the context of a file).</li> </ol> Example<pre><code>the first line of code;  // comment text\n\n/* comment text\n * comment text\n * comment text\n */\n\n line of code;          // comment text\n another line of code;  // comment text\n</code></pre> <ol> <li>Assume the reader is competent in the language, and avoid explaining the obvious. (You aren't trying to hit a comment count for an assignment, you're trying to actually be helpful to yourself and others in the future)</li> <li>Single line comments should be used where the function of a single line may be ambiguous.</li> </ol>"},{"location":"electrical/embedded/styleguide/#comment-locations","title":"Comment Locations","text":"<ol> <li>Functions should be preceeded by a short comment block explaining the relevant values (inputs, outputs) and an extremely brief description of the purpose of the function. This comment block should follow Doxygen styling, linked here.</li> </ol> Example<pre><code>/**\n * Sums two numbers\n * @param A an integer\n * @param B an integer\n * @return The summation\n */\nint sum(int A, int B) {\n    int c;\n    c = a + b;\n    return c;\n}\n</code></pre>"},{"location":"electrical/embedded/styleguide/#white-space-rules","title":"White Space Rules","text":"<ol> <li>The keywords <code>if, while, for, switch,</code> and <code>return</code> should be followed by a single space if there is more text on the same line.</li> <li>Unless specified by another whitespace rule, all operators should be surrounded on either side by a single space.</li> <li>Unary operators should not have a space between the operator and the operand.</li> <li>Structure pointer and member operators should have no whitespace on either side.</li> <li>Parentheses, braces, and brackets should not have an adjacent space on the interior side.</li> <li>Excluding the end of a line, separating commas should should be followed by one space.</li> <li>Semicolons should follow a preceeding statement without a space, but should always be followed by a space unless they end a line.</li> <li>Use whitespace to separate blocks of code from each other in a logical fashion. It is suggested to use either 1 or 3 lines of separation, case dependent.</li> </ol>"},{"location":"electrical/embedded/styleguide/#pointer-and-operators","title":"Pointer (* and &amp;) Operators","text":"<ol> <li>Pointer operators should be written without a space on the operand side (i.e. <code>type *name</code>).</li> <li>Pointer variables should be declared on a line separate from non-pointer variables of the same type, to avoid confusion between the two.</li> </ol>"},{"location":"electrical/embedded/styleguide/#alignment-rules","title":"Alignment Rules","text":"<ol> <li>The # of a preprocessor directive should always be left aligned, regardless of the indentation of the line.</li> <li>Align relevant blocks of code together (Don't be stupid).     TODO: Make this nicer?</li> </ol>"},{"location":"electrical/embedded/styleguide/#tab-rules","title":"Tab Rules","text":"<ol> <li>The unicode tab character should not appear in files. Instead, the specified tab size is 4 spaces.</li> </ol>"},{"location":"electrical/embedded/styleguide/#module-rules","title":"Module Rules","text":""},{"location":"electrical/embedded/styleguide/#naming-conventions","title":"Naming Conventions","text":"<ol> <li>File names should consist only of lower case letters, numbers, and underscores.</li> <li>File names are recommended to be no longer than 16 characters. Ideally file names are specific and short, like the file itself.</li> <li>All module names should not overlap with those of the standard library.</li> <li>All files that contain a <code>main()</code> function should include \"main\" within the filename. In general, there will be only one file containing a main function. In this case, the file hsould be named <code>main.c</code> or <code>main.cpp</code>.</li> </ol>"},{"location":"electrical/embedded/styleguide/#header-files","title":"Header Files","text":"<ol> <li>Include preprocessor guards against multiple inclusion within all header files (#ifndef NAME_H)</li> <li><code>#pragma once</code> should not be used for protection against multiple files, see previous rule for alternative.</li> <li>No variables should be defined within a header file, nor should any storage be allocated.</li> <li>Header files should concern themselves strictly with the information that is needed to be known by other modules. (Everything else should be declared within the source file itself)</li> <li>Unless required for a specific purpose, headers and source files should always be paired. Multiple source files per header file is discouraged.</li> </ol>"},{"location":"electrical/embedded/styleguide/#source-files","title":"Source Files","text":"<ol> <li>Source files should be specific, and contain only the information relevant to controlling one 'domain' (UART driver, Servo control, etc).</li> <li>Source files should always <code>#include</code> the corresponding header file.</li> <li>No absolute or relative paths should be used in <code>#include</code> statements. Instead, the build system should be used to include relevant links.</li> <li>Do not include extraneous <code>#include</code> statements.</li> <li>Do not directly <code>#include</code> another source file; always <code>#include</code> the relevant header file.</li> <li>Any variables shared internally across the entire module but that aren't declared according to the rules of the header file should be declared at the top of the module's source file.</li> </ol>"},{"location":"electrical/embedded/styleguide/#data-type-rules","title":"Data Type Rules","text":""},{"location":"electrical/embedded/styleguide/#type-definitions","title":"Type Definitions","text":"<ol> <li>When defining new data types, they should always be appended with the <code>_t</code> designation.</li> <li>Structs and enums should be implemented only through <code>typedef</code> declarations.</li> <li>Any data types that are <code>public</code> should have their module name prepended to them in the pattern <code>module_type</code>.</li> <li>Any data types that are <code>public</code> are to be declared in their module's respective header file.</li> <li>Any data types that are <code>private</code> are to be declared in their module's respective source file.</li> </ol>"},{"location":"electrical/embedded/styleguide/#use-of-types","title":"Use of Types","text":"<ol> <li>Any time a specific number of bits needs to be used, one of the fixed-width integer types defined in <code>stdint.h</code> should be used, rather than one of the named types (short, long, long long).</li> <li><code>char</code> types should be used only when related to strings; See rule 1 in this subsection.</li> <li><code>bool</code> types should be used from the C standard library (<code>stdbool.h</code>), rather than defined using enums or preprocessor directives.</li> <li>Bit fields--such as those used for register mapping--should be defined only within unsigned integer types.</li> <li>Bitwise operations should only be done on unsigned integer types.</li> <li>Signed and unsigned integers should preferably never be mixed within operations</li> <li>Avoid floating point operations wherever practical.     (There is some discretion required here. If it makes sense to do floating point (you have an FPU, it would violate common mathematical assumptions to do otherwise, etc.) proceed accordingly.)</li> </ol> <p>TODO: Add content pertaining to unions</p>"},{"location":"electrical/embedded/styleguide/#procedure-rules","title":"Procedure Rules","text":"<p>TODO: content</p>"},{"location":"electrical/embedded/styleguide/#variable-rules","title":"Variable Rules","text":"<p>TODO: content</p>"},{"location":"electrical/embedded/styleguide/#statement-rules","title":"Statement Rules","text":"<p>TODO: content</p>"},{"location":"electrical/software/kicad/","title":"KiCad User Guide","text":"<p>Note that this page is currently an outline and most of the content is not yet written.</p> <p>This user guide is intended to be a reference, not a tutorial. There are many good KiCad tutorials available online, however please note that there are sometimes multiple ways to do things in KiCad (eg library management). In such cases, please use the methods described on this page. Part of this page's purpose is to describe our conventions / approaches to using KiCad.</p> <p>Note that this guide was written for KiCad 7.0.1</p>"},{"location":"electrical/software/kicad/#installation","title":"Installation","text":"<p>See the Software Overview page for download links and required version information (if any).</p>"},{"location":"electrical/software/kicad/#windows","title":"Windows","text":"<ul> <li>Download the installer (<code>exe</code> file)</li> <li>Run the installer. It will require administrative privileges.</li> <li>Follow the instructions of the installer. Default settings / options are sufficient.</li> <li>Install SWLib (see instructions in following section) after the installation completes.</li> </ul>"},{"location":"electrical/software/kicad/#macos","title":"macOS","text":"<ul> <li>Download the <code>dmg</code> file</li> <li>Open the dmg disk image</li> <li>Drag the <code>KiCad</code> folder to <code>Applications</code> as indicated by the arrow</li> <li>Wait for the copy operation to complete</li> <li>KiCad is now installed</li> <li>Install SWLib (see instructions in following section) after the installation completes.</li> </ul>"},{"location":"electrical/software/kicad/#linux","title":"Linux","text":"<ul> <li>Follow KiCad's Instructions. On Ubuntu this entails adding a ppa and installing the packages.</li> <li>Install SWLib (see instructions in following section) after the installation completes.</li> </ul>"},{"location":"electrical/software/kicad/#swlib","title":"SWLib","text":"<p>SWLib is a KiCad library containing symbols, footprints, and 3D models for components used on SeaWolf's boards. This library is shared among many robots (not SeaWolf VIII exclusive).</p> <p>This library must be installed once per system you install KiCad on.</p> <p>Note: you must have <code>git</code> installed to install, modify, or update SWLib!</p>"},{"location":"electrical/software/kicad/#installation_1","title":"Installation","text":"<ol> <li>Clone this repository somewhere on your system. The location does not matter. On windows, avoid putting it in OneDrive (ie don't put it in your documents folder).</li> <li>Open KiCad. Close any open project (File &gt; Close Project)</li> <li>Preferences &gt; Manage Symbol Libraries</li> <li>The first time you open this menu, you will be asked to \"Configure Global Symbol Library Table\". Choose \"Copy Default Global Symbol Table\"</li> <li>On the Global Libraries tab select the folder icon at the bottom (Add existing library to table)</li> <li>Navigate to wherever you cloned the repo. Choose the <code>SWLib.kicad_sym</code> file.</li> <li>Click OK to close the symbol library table.</li> <li>Preferences &gt; Manage Footprint Libraries</li> <li>The first time you open this menu, you will be asked to \"Configure Global Footprint Library Table\". Choose \"Copy Default Global Footprint Table\"</li> <li>On the Global Libraries tab select the folder icon at the bottom (Add existing library to table)</li> <li>Navigate to wherever you cloned the repo. Choose the <code>SWLib.pretty</code> folder.</li> </ol>"},{"location":"electrical/software/kicad/#updating","title":"Updating","text":"<ol> <li>Open a terminal or git bash in the folder you cloned the repository to.</li> <li>Run <code>git pull origin main</code></li> </ol>"},{"location":"electrical/software/kicad/#creating-new-parts","title":"Creating new Parts","text":"<p>Before creating a new part, check if it exists in one of the builtin KiCad libraries. Many parts do. You can search in the symbol editor.</p> <p>To create a new part, it is necessary to create both a symbol and footprint for the part. Symbols are used in schematics. Footprints are used on the PCB. In their simplest form, both are a collection of pins with unique numbers. On a symbol, pins are \"lines\". On a footprint, pins are \"holes\" or \"pads\" that go in / on the PCB. Pins on a symbol are associated with pins on a footprint by the pin's number. In addition to numbers, pins on a symbol can have human readable names. These are only used to show the designer what the pin is called.</p> <p>To start, create the symbol</p> <ol> <li>Open the symbol editor (in KiCad's main window)</li> <li>Select SWLib in the libraries panel on the left</li> <li>Select the new symbol button (or <code>File &gt; New Symbol...</code>)</li> <li>Name the symbol. This should typically match the name of the part you are making a symbol for.</li> <li>Optionally select an existing symbol to derive from (\"start with\")</li> <li>Change the designator if needed. See this</li> <li>Typically, units per package should be left as 1</li> <li> <p>Leave other settings unchanged</p> <p></p> </li> <li> <p>Click OK to create you symbol. It will be open in the editor.</p> </li> <li>Make sure the unit is set to \"mil\" on the left hand toolbar.</li> <li>Make sure the grid is set to 50mil (<code>View &gt; Grid Properties</code>). You can see the current grid on the bottom bar.</li> <li>Create the symbol. You can use the tools on the right toolbar to \"draw\" the symbol (lines, shapes, arcs). Draw your part centered on the origin!</li> <li>Then use the \"pin\" tool (right toolbar) to add the required number of pins. Name the pins using the names in the part's datasheet. Make sure the pin number match the part's package pin numbers. When creating pins, the \"circle\" should be facing out. THis is where wires connect to in the schematic.</li> <li>Make sure to drag the designator above the part</li> <li> <p>Save!</p> <p></p> </li> </ol> <p>After creating the symbol, determine if you need to create a footprint. KiCad's footprint libraries have a footprint for most standard packages (0603, 0805, 1206, etc for resistors, capacitors, diodes, inductors; QFP, TSSOP, SOIC, DIP, QFN, etc for ICs). Open the footprint editor and search for the package your device uses. If it exists, do not create a custom footprint. Skip to step 6. If you do need to create the footprint, follow the instructions below.</p> <ol> <li>Open the footprint editor</li> <li>Select \"SWLib\" in the left panel with all libraries</li> <li>Select <code>File &gt; New Footprint</code> to create an empty footprint. Name it the same as your part.</li> <li>Use the footprint editor to place pads and draw any desired silkscreen. Make sure the numbers of the pads match the numbers of the pins the pad should be associated with. Follow numbering convention in the part's datasheet.</li> <li> <p>Save!</p> <p></p> </li> <li> <p>Go back to your part in the Symbol editor.</p> </li> <li>Edit symbol properties (<code>File &gt; Symbol Properties...</code>)</li> <li>Click the library icon next to the footprint field (you may need to click the footprint field first).</li> <li>Select the footprint for your part</li> <li>Double check the pin number order of the footprint and schematic. This is especially important if you are using a footprint you did not make.</li> <li>Save!</li> </ol> <p>Optionally, you can add a 3D model to a footprint.</p> <ol> <li>Create or download a 3D mode. Save it as a step or stl file in <code>SW-KicadLibrary/SWLib.3d</code>. Name it the same as the part.</li> <li>Open the footprint editor and select your part.</li> <li>Edit footprint properties (<code>File &gt; Footprint Properties...</code>)</li> <li>Select the 3D models tab</li> <li>Click the plus button and type the following. Never use the browse feature to select a 3d model! Browse tool uses absolute paths, which will break the model on other people's systems.     <pre><code>../../SWLib.3d/[FILE].step\n</code></pre></li> <li>Replace <code>[FILE]</code> with the name of the step file. This is case sensitive!.</li> <li>Close the properties panel and save the footprint.</li> </ol> <p>After creating your part (and saving everything) commit your changes in the <code>SW-KicadLibrary</code> repo and push.</p>"},{"location":"electrical/software/kicad/#importing-downloaded-parts","title":"Importing Downloaded Parts","text":"<p>Many parts will have footprints and symbols (ECAD models) available for download. These often include 3D models too. Some common sources to find these models are</p> <ul> <li>SamacSys (easiest to access through mosuer; DO NOT INSTALL THE LIBRARY LOADER! DO NOT USE IT!)</li> <li>UltraLibrarian</li> <li>SnapEDA</li> </ul> <p>Note that you will need an account to use any of these services. </p> <ol> <li>When downloading a model, download symbol and footprint. If a 3D model is available, download it too.</li> <li> <p>After downloading, follow the instructions below depending on where you downloaded the model from. Note that if a 3D model was not available, the 3D model file will be missing.</p> SamacSys <p>The downloaded file will be a <code>.zip</code> file. Extract it.Locate the following three files.</p> <ul> <li>Symbol: <code>[PART]/KiCad/[PART].kicad_sym</code> (older parts may only have a <code>.lib</code> file. This works too.)</li> <li>Footprint: <code>[PART]/KiCad/[PACKAGE].kicad_mod</code></li> <li>3D Model: <code>[PART]/3D/[PART].stp</code></li> </ul> UltraLibrarian <p>The downloaded file will be a <code>.zip</code> file. Extract it.Locate the following three files.</p> <ul> <li>Symbol: <code>KiCAD/[NAME]/[NAME].lib</code></li> <li>Footprint: <code>KiCAD/[NAME]/footprints.pretty/[NAME].kicad_mod</code></li> <li>3D Model: <code>[NAME]/STEP/[NAME].step</code></li> </ul> SnapEDA <p>The downloaded file will be a <code>.zip</code> file. Extract it.Locate the following three files.</p> <ul> <li>Symbol: <code>[PART].kicad_sym</code></li> <li>Footprint: <code>[PART].kicad_mod</code></li> <li>3D Model: <code>[PART].step</code></li> </ul> </li> <li> <p>Open KiCad's symbol editor</p> </li> <li>Find SWLib in the panel on the left.</li> <li>Right click \"SWLib\" and choose \"Import Symbol...\"</li> <li>Choose the symbol file (<code>.lib</code>) described above.</li> <li>Save the symbol.</li> <li>Open the footprint editor.</li> <li>Find SWLib in the panel on the left.</li> <li>Right click \"SWLib\" and choose \"Import Footprint...\"</li> <li>Choose the footprint file (<code>.kicad_mod</code>) described above.</li> <li>Save into SWLib</li> <li>Copy the 3D model file (<code>.step</code> / <code>.stp</code> file described above) to SWLib. This must be copied to wherever you cloned SWLib. Paste the <code>.step</code> file into <code>SW-KicadLibrary/SWLib.3d</code></li> <li>In the footprint editor, edit footprint properties (<code>File &gt; Footprint Properties...</code>)</li> <li>Select the 3D models tab</li> <li>Click the plus button and type the following. Never use the browse feature to select a 3d model! Browse tool uses absolute paths, which will break the model on other people's systems.     <pre><code>../../SWLib.3d/[FILE].step\n</code></pre></li> <li>Replace <code>[FILE]</code> with the name of the step file. This is case sensitive!. Change <code>step</code> to a different suffix if the file uses a different suffix.</li> <li>Close the properties panel and save the footprint.</li> <li>Go back to the symbol editor and select the imported symbol.</li> <li>Open symbol properties (<code>File &gt; Symbol Properties...</code>)</li> <li>Click the footprint field, then select the browse button</li> <li>Choose the footprint now imported into the SWLib footprint library</li> <li>Close the symbol properties panel and save.</li> </ol> <p>After importing your part (and saving everything) commit your changes in the <code>SW-KicadLibrary</code> repo and push.</p>"},{"location":"electrical/software/kicad/#creating-a-new-project","title":"Creating a New Project","text":"<p>Make sure you have installed SWLib first!</p> <p>TODO</p>"},{"location":"electrical/software/kicad/#opening-an-existing-project","title":"Opening an Existing Project","text":"<p>Make sure you have installed SWLib first!</p> <p>TODO</p>"},{"location":"electrical/software/kicad/#design-workflow","title":"Design Workflow","text":""},{"location":"electrical/software/kicad/#schematic","title":"Schematic","text":"<p>Always use a 50mil grid in the schematic editor! If absolutely necessary, a 25mil grid can be used occasionally, but try to avoid doing so.</p> <p>TODO: General schematic work</p> <p>TODO: Symbol table conventions and custom part number field</p> <p>TODO: Net label and power port behavior across multiple schematic sheets</p>"},{"location":"electrical/software/kicad/#electrical-rules-check","title":"Electrical Rules Check","text":"<p>TODO</p>"},{"location":"electrical/software/kicad/#assign-footprints","title":"Assign footprints","text":"<p>TODO (note bulk procedures too)</p>"},{"location":"electrical/software/kicad/#pcb-setup","title":"PCB Setup","text":"<p>It is generally necessary to setup some board stackup parameters (specifically the number of copper layers) before starting the PCB. In order to make running DRCs later, it is best to import board settings from one of the SW-KiCadTemplates. These templates are based on PCB manufacturer board stackups and include design rules. Specifics (such as board color, default item sizes, etc) can be customized after importing a template. To import a template, follow the steps listed below</p> <ol> <li>Download a zip of the repo and extract the zip (or just clone it)</li> <li>Open your project in KiCad</li> <li>Open your PCB</li> <li>Open Board Setup (<code>File &gt; Board Setup</code>)</li> <li>Click the button on the bottom left labeled \"Import Settings from Another Board\"</li> <li>Choose the <code>kicad_pcb</code> file for the template you want to use. Which template is used should depend on how you plan to design the PCB (number of layers, impedance control, etc) as well as who you plan to have manufacture the PCB.</li> <li>After selecting a template file, click the \"Select All\" button (rarely will you want to import only some settings)</li> <li>Click \"Import Settings\"</li> <li>Click \"OK\" to close the board setup dialog</li> <li>Save the PCB file</li> <li>Restart KiCad (Close fully and reopen the project). Skipping this step can cause library issues until KiCad is restarted.</li> </ol>"},{"location":"electrical/software/kicad/#pcb-layout-routing","title":"PCB Layout &amp; Routing","text":"<p>Always work in mil not mm grid!</p> <p>TODO</p>"},{"location":"electrical/software/kicad/#design-rules-check-drc","title":"Design Rules Check (DRC)","text":"<ol> <li>Setup design rules in Boards Setup (<code>File &gt; Board Setup</code>). Fill in options for <code>Design Rules &gt; Constraints</code> and change defaults in <code>Text &amp; Graphics &gt; Defaults</code> as applicable. Skip this if you imported board settings from one of the template boards! Close Board Setup dialog when done.</li> <li>Open the design rules checker dialog (<code>Inspect &gt; Design Rules Checker</code>)</li> <li>At the top, select only \"Refill all zones before performing DRC\"</li> <li>Make sure both errors and warnings are shown (checkboxes near bottom of the dialog)</li> <li>Run the DRC</li> <li>Fix any errors.</li> <li>Fix or waive warnings as warranted.</li> </ol>"},{"location":"electrical/software/kicad/#tips-and-tricks","title":"Tips and Tricks","text":""},{"location":"electrical/software/kicad/#flat-multi-page-schematics","title":"Flat multi-page Schematics","text":"<p>There are two common ways of doing multi-page schematics: Hierarchical and flat. Hierarchical design embeds one sheet as a block in another. Connections between sheets are made using ports. Flat designs have multiple sheets (all considered top level). Connections between sheets are made by naming nets the same name. AquaPack prefers to use Hierarchical design over flat design practices.</p> <p>In rare cases it may be acceptable to use a flat design, however KiCad doesn't really support them well. You still have to create a top level schematic and add all your sheets as blocks to it. However you just won't add ports or make connections. The top level sheet just acts as a container.</p>"},{"location":"electrical/software/kicad/#handsolder-footprints","title":"HandSolder Footprints","text":"<p>The builtin KiCad footprint libraries often have two variants of footprints (eg for resistors, capacitors, etc). One is often suffixed \"HandSolder\". These footprints use elongated pads that make it easier to solder components to the board by hand. These are generally preferred for our use cases.</p>"},{"location":"electrical/software/kicad/#mounting-holes","title":"Mounting Holes","text":"<p>Do not use vias or manually placed pads for mounting holes. This will lead to DRC warnings / errors. Instead use footprints from the builtin \"MountingHole\" library. These footprints can be added to the PCB without corresponding symbols in the schematic by using the \"Add Footprint\" option in the PCB editor (<code>Place &gt; Add Footprint</code>). After adding the footprint, make sure to edit its properties and check the \"Not in schematic\" box.</p>"},{"location":"electrical/software/kicad/#silkscreen-text-size","title":"Silkscreen Text size","text":"<p>Most manufacturers specify limits on character height and stroke width. KiCad also wants a character width. Always make this equal the the height of your characters!</p>"},{"location":"electrical/software/kicad/#adding-images-to-silkscreen","title":"Adding Images to Silkscreen","text":"<ol> <li>Open the project you want to add images to</li> <li>In KiCad's project window open the \"Image Converter\"</li> <li>Click Load Image and choose the image you want to add. Monochrome bitmaps work well. Other image formats work, but you may need to adjust the black / white threshold.</li> <li>Choose the size of the image in \"Output Size\" (if not sure what size you want guess; trial and error is the way to go)</li> <li>Choose \"Footprint (.kicad_mod file)\" for Output Format</li> <li>Make sure \"Front Silkscreen\" is selected for the layer</li> <li>Click \"Export to Clipboard\" (there is generally no reason to save graphics as symbol files)</li> <li>Open the PCB (it is recommended to still leave the image converter window open for now too)</li> <li>Paste the symbol (Ctrl+V for normal people or CMD+V on mac) and place it where you want on the board</li> <li>To place on the back of the board, press the F key with the graphic selected.</li> <li>If the size is wrong, do not attempt to resize it in the PCB. Go back to the image converter window, change the size and export to clipboard again. Paste it into the PCB again. Repeat as needed.</li> <li>Once the graphic is paced where you want it, double click it to open its properties (footprint properties) and uncheck the \"Show\" box next to \"Reference Designator\". Click OK to close the dialog.</li> <li>Note that when you run the DRC check, there will be a footprint warning about the graphic. Just exclude the violation.</li> </ol>"},{"location":"electrical/software/kicad/#thermal-relief-connections-to-pads","title":"Thermal Relief Connections to Pads","text":"<p>When connecting a zone to a pad, it will be thermally relieved by default. This means it will be connected with \"spokes\" instead of solid copper. This is usually desirable, however it can be disabled in the properties of the zone if you need to or specific cases (usually only necessary for high current or if using copper on the board as a heatsink).</p>"},{"location":"electrical/software/kicad/#other-useful-options-features-of-pcb-editor","title":"Other Useful Options / Features of PCB Editor","text":"<ul> <li>You can fill or unfill all copper zones (sometimes called \"polygons\" or \"pours\" or \"planes\") by using <code>Edit &gt; Fill All Zones</code> and <code>Edit &gt; Unfill All Zones</code>. Unfilling zones is useful while working on the board. Filling them lets you see how the zone will be filled after updating the zone itself.</li> <li>You can flip the board view using <code>View &gt; Flip Board View</code>. This is sometimes useful if working on the back of the board. This pairs well with the layer presets on the right below the layer selector (for example, select the all back layers preset).</li> <li>When editing tracks (traces) you can select one part and use the \"U\" and \"I\" keys to select more or less of the track.</li> <li>You can bulk edit fonts of silkscreen text using <code>Edit &gt; Edit Text and Graphics Properties...</code>.</li> <li>You can automatically cleanup traces and vias (remove redundant segments, etc) using <code>Tools &gt; Cleanup Tracks and Vias...</code>. However, be careful with the \"Delete redundant vias\" option. This may delete vias you wanted multiple of for current or heat reasons.</li> </ul>"},{"location":"electrical/software/overview/","title":"Overview","text":"<p>There are various tools and pieces of software used in relation to the electrical design of SeaWolf VIII. These are listed below</p>"},{"location":"electrical/software/overview/#pcb-design","title":"PCB Design","text":""},{"location":"electrical/software/overview/#kicad","title":"KiCad","text":"<p>Required Operating System: Windows, macOS, Linux</p> <p>Download Links: KiCad</p> <p>Used to design PCBs and schematics for various custom boards in use on SeaWolf VIII. KiCad is a free and open source Electronic Design Automation (EDA) tool which is generally easy to learn to use, but powerful enough when needed.</p> <p></p>"},{"location":"electrical/software/overview/#altium-designer","title":"Altium Designer","text":"<p>Required Operating System: Windows</p> <p>Download Links: Altium Designer (license either through university or AquaPack)</p> <p>Many SeaWolf VIII boards were originally designed using Altium Designer. Altium Designer is a proprietary EDA tool. While more commonly used in industry than KiCad, the decision was ultimately made to move to KiCad to simplify library management, reduce software learning curves, and improve operating system compatibility.</p> <p></p>"},{"location":"electrical/software/overview/#msp430-embedded-firmware","title":"MSP430 Embedded Firmware","text":"<p>Custom PCBs used on SeaWolf VIII are designed around TI's MSP430 MCUs or Launchpad development boards. The firmware for these boards is developed using one of the following tools. Note that IAR is intentionally avoided. TI's CCS is free and fully featured with no code size limit. Additionally, IAR's evaluation license only allows access to the newest version of IAR which can make project compatibility and maintenance difficult.</p>"},{"location":"electrical/software/overview/#arduino-energia","title":"Arduino / Energia","text":"<p>Required Operating System: Windows, macOS, Linux</p> <p>Download Links: Arduino IDE | MSP430 Core</p> <p>While the Energia project is officially unmaintained since November 2022, there are builds of the Energia MSP430 Arduino core located at the link above. These builds user newer tooling and fix bugs with some of the chips used. This core can be installed with the official Arduino IDE.</p> <p>Generally, this is used only during prototyping or when rapid firmware development is required.</p> <p></p>"},{"location":"electrical/software/overview/#ti-code-composer-studio-ccs","title":"TI Code Composer Studio (CCS)","text":"<p>Required Operating System: Windows, macOS, Linux</p> <p>Download Link: TI CCS | MSP430 GCC</p> <p>TI's Code Composer Studiohttps://www.ti.com/design-resources/embedded-development/ccs-development-tools.html supports the MSP430 chips using TI's compiler or a separately installed open source GCC compiler. This IDE is Eclipse based and integrates a debugger among many other tools.</p> <p></p>"},{"location":"electrical/software/overview/#circuit-simulation","title":"Circuit Simulation","text":""},{"location":"electrical/software/overview/#ltspice","title":"LTSpice","text":"<p>Required Operating System: Windows, macOS, Linux (through Wine)</p> <p>Download Link: LTSpice</p> <p>LTSpice is a free circuit simulator with builtin models for many Analog Devies / Linear Tech chips. This is generally our preferred circuit simulator as it is easy to install and use. In some cases however, models designed for PSpice (usually TI parts) are not compatible (they are either encrypted or use PSpice features that LTSpice does not have). In these cases other software is used.</p> <p></p>"},{"location":"electrical/software/overview/#pspice-for-ti","title":"PSpice for TI","text":"<p>Required Operating System: Windows</p> <p>Download Link: PSpice for TI (requires TI account and export approval)</p> <p>PSpice for TI is a limited feature version of Cadance's PSpice simulator. It is more difficult to setup, thus we generally prefer LTSpice, however there are cases where this should be used instead (when a TI model is encrypted or when a model uses PSpice features that LTSpice does not support). Note that using ADI / LT devices is often not possible in PSpice. ADI / LT typically provide encrypted LTSpice models only.</p> <p></p>"},{"location":"electrical/software/overview/#hardware-design-fpga","title":"Hardware Design (FPGA)","text":""},{"location":"electrical/software/overview/#vivado-vitis","title":"Vivado &amp; Vitis","text":"<p>Required Operating System: Windows, Linux</p> <p>Download Link: Vivado ML Edition (requires AMD account and export approval)</p> <p>Vivado is used with our Digilent Basys3 FPGA dev board used for the Acoustics system. Vivado is currently used for synthesis, implementation, and bitstreaming. Going forward we intend to explore Vivado's simulation functions too.</p> <p></p>"},{"location":"electrical/software/overview/#scientific-computing","title":"Scientific Computing","text":"<p>Generally used for mathematic modeling, validation, or simulation.</p>"},{"location":"electrical/software/overview/#matlab","title":"MATLAB","text":"<p>Required Operating System: Windows, macOS, Linux</p> <p>Download Link: Accessed through university. Follow university instructions.</p> <p>If MATLAB is available, it is generally advisable to use it over GNU Octave as MATLAB is faster and better supported.</p> <p></p>"},{"location":"electrical/software/overview/#gnu-octave","title":"GNU Octave","text":"<p>Required Operating System: Windows, macOS, Linux</p> <p>Download Link: GNU Octave</p> <p>If MATLAB is not available, GNU Octave is compatible with many MATLAB programs. GNU Octave is free and open source with many packages similar to MATLAB toolboxes as well. While generally compatible with MATLAB code, Octave does not implement all functions. In particular many more recent MATLAB \"helper\" functions (ie advanced string manipulation functions) are not implemented and require more complex sets of operations to replicate in Octave. However, most core math functions are implemented in Octave.</p> <p>Due to the few compatibility issues Octave may have, and the fact that Octave is likely slower than MATLAB, it is usually recommended to use MATLAB if a license is available.</p> <p></p>"},{"location":"electrical/software/overview/#python-3rd-party-packages","title":"Python + 3rd Party Packages","text":"<p>Required Operating System: Windows, macOS, Linux</p> <p>Download Links: Python 3 | NumPy | SciPy | Matplotlib (On Linux use distribution package manager to install python3)</p> <p>Instead of MATLAB it is sometimes preferred (personal preference, language experience, better tool for the particular job, etc) to use Python with a few third party libraries. These libraries are usually <code>numpy</code>, <code>scipy</code>, and <code>matplotlib</code> (install these packages with <code>pip</code>). These libraries can allow python to be a very useful scientific computing tool for many similar applications to how MATLAB or Octave may be used.</p>"},{"location":"electrical/software/overview/#other","title":"Other","text":""},{"location":"electrical/software/overview/#git-scm","title":"Git SCM","text":"<p>Required Operating System: Windows, macOS, Linux</p> <p>Download Link: Git SCM (On macOS install Xcode command line tools; On linux install using distribution package manager)</p> <p>Most of our PCB design files and embedded firmware source code is located in GitHub which uses git as a source control / version control tool. You will need <code>git</code> installed on your computer to use these repositories.</p>"},{"location":"electrical/software/overview/#digilent-waveforms","title":"Digilent WaveForms","text":"<p>Required Operating System: Windows, macOS, Linux</p> <p>Download Link: WaveForms | Adept Runtime (On Linux make sure to install the Adept runtime first. This is not required on Windows or macOS)</p> <p>Many members of the club have an Analog Discover 2 from coursework. WaveForms allows this to be used as an oscilloscope, logic analyzer, waveform generator, spectrum analyzer, and many more tools.</p> <p></p>"},{"location":"mechanical/dropper/","title":"Dropper","text":"<p>Put dropper documentation here</p>"},{"location":"mechanical/torpedo/","title":"Torpedo","text":"<p>Put torpedo documentation here</p>"}]}